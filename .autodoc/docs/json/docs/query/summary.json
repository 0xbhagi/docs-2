{
  "folderName": "query",
  "folderPath": ".autodoc/docs/json/docs/query",
  "url": "https://dune.com/.autodoc/docs/json/docs/query",
  "files": [
    {
      "fileName": "dunesql-changes.md",
      "filePath": "docs/query/dunesql-changes.md",
      "url": "https://dune.com/docs/query/dunesql-changes.md",
      "summary": "# DuneSQL migration\n\nThis technical guide provides documentation regarding the changes to DuneSQL that occurred on March 2nd, 2023. The guide is divided into several sections, each of which covers a specific aspect of the migration. \n\nThe first section of the guide explains the changes that were made to DuneSQL. Specifically, DuneSQL now uses the same data types as the underlying EVM blockchain. This means that addresses, transaction hashes, and other encoded data are now stored as `varbinary` datatype. Additionally, `uint256` and `int256` are now supported, allowing for full wei-level precision calculations. The guide also explains that logs are now indexed from 0 instead of 1, and the `from_hex` native function has been modified to transform varchar to varbinary.\n\nThe second section of the guide explains what these changes mean for users. The switch to the `varbinary` datatype should significantly improve query speed, and the removal of string casts and conversions should make queries more readable and easier to maintain. Additionally, the introduction of `uint256` and `int256` allows for full wei-level precision calculations. \n\nThe third section of the guide explains what users need to do to adjust to these changes. Specifically, users need to remove the `-- dunesql_alpha_deprecated` comment from their queries, adjust all occurrences of `0x` strings to fit the new data types, and remove any `varchar -> double`, `varchar -> decimals`, or `varchar -> bigint` casts. If queries used any columns from logs tables, users will need to adjust the indexing of topics. \n\nThe fourth section of the guide explains what will happen if users do not adjust their queries. If the `-- dunesql_alpha_deprecated` comment is not removed from a query, it will continue to run against the old data types until March 23, 2023. After that date, the query will no longer run, and users will need to update it to use compatible functions.\n\nThe fifth section of the guide provides a table of common errors and fixes that users may encounter. \n\nOverall, this technical guide provides a comprehensive overview of the changes that were made to DuneSQL and what users need to do to adjust to these changes. It also provides examples of queries that need to be adjusted and common errors that users may encounter.",
      "questions": "1. What are the current issues with datatypes in some tables in DuneSQL and when are they expected to be resolved?\n- The current issues with datatypes in some tables in DuneSQL are affecting some Spellbook tables, `snapshot.*` and `cowswap.*`, and can be temporarily fixed by casting the columns which are incorrectly still `varchar` to `varbinary` with `from_hex(x)`. The issue is still to be resolved and there is no expected date for the resolution.\n\n2. What are the benefits of switching to the `varbinary` datatype in DuneSQL?\n- Switching to the `varbinary` datatype should significantly improve the speed of queries by approximately 30%. Additionally, it eliminates the need for string casts and conversions, making queries more readable and easier to maintain. Finally, the introduction of `uint256` and `int256` allows for full wei-level precision calculations.\n\n3. What are some common errors and fixes that might be encountered when using DuneSQL after the changes?\n- Some common errors and fixes that might be encountered when using DuneSQL after the changes include needing to cast varchar to varbinary using `from_hex(x)`, casting to `uint256` using `cast(xxx as uint256)`, using `bytearray_substring` and `bytearray_starts_with` instead of LIKE expression, and adjusting the indexing of topics in logs tables from `Topic1` to `Topic0`, `Topic2` to `Topic1`, etc."
    },
    {
      "fileName": "index.md",
      "filePath": "docs/query/index.md",
      "url": "https://dune.com/docs/query/index.md",
      "summary": "# DuneSQL: Query Engine for Blockchain Data\n\nThe DuneSQL app technical guide provides an overview of the custom-built query engine designed for efficient analysis of blockchain data. DuneSQL is a fork of TrinoSQL, an open-source, distributed SQL query engine for running interactive analytic queries against data sources of all sizes ranging from gigabytes to petabytes. The guide highlights the additional optimizations incorporated into DuneSQL to handle blockchain-specific requirements.\n\nThe guide outlines the features of DuneSQL, including blockchain varbinary data types, native support for uint256 and int256 data types, columnar storage format, and querying a query. The blockchain varbinary data types are designed for storing addresses, hashes, and other encoded data. The native support for uint256 and int256 data types is ideal for handling large numbers commonly found in blockchain data, with built-in functions for ease of use. The columnar storage format is optimized for fast reads, organizing data in columns rather than rows, enabling quick access to single columns for aggregation or filtering. Querying a query allows users to create reusable queries, build up complex queries, and reuse queries as views.\n\nThe guide provides extensive documentation for DuneSQL, which can be found in the DuneSQL Reference section of the documentation. The DuneSQL Reference section includes SQL statement reference, SQL language reference, and functions and operators. The guide also highlights the importance of understanding DuneSQL storage for an efficient query-writing process. The Storage section of the documentation provides details on the database layout and querying techniques.\n\nThe guide provides resources and support for assistance with DuneSQL, including a Google search for TrinoSQL-related queries, talking to an AI assistant about TrinoSQL-related questions, and the official Trino docs - Functions and Operators. Users can also join the #dune-sql Discord channel to connect with the team and the community for help and support.\n\nFinally, the guide encourages feedback and suggestions for improvement. Users can email dunesql-feedback@dune.com with any concerns or ideas for optimization.\n\nOverall, the DuneSQL app technical guide provides a comprehensive overview of the custom-built query engine designed for efficient analysis of blockchain data. The guide highlights the features of DuneSQL, provides extensive documentation, and offers resources and support for assistance with DuneSQL.",
      "questions": "1. What optimizations does DuneSQL incorporate to handle blockchain-specific requirements?\n- DuneSQL incorporates additional optimizations to handle blockchain-specific requirements, but the specific details are not provided in the app technical guide.\n\n2. What blockchain data types does DuneSQL support?\n- DuneSQL supports blockchain varbinary data types for storing addresses, hashes, and other encoded data, as well as native support for uint256 and int256 data types for handling large numbers commonly found in blockchain data.\n\n3. What resources are available for assistance with DuneSQL?\n- Resources for assistance with DuneSQL include a Google search for TrinoSQL-related queries, talking to an AI assistant about TrinoSQL-related questions, joining the #dune-sql Discord channel, and referring to the official Trino docs for functions and operators."
    },
    {
      "fileName": "query-a-query.md",
      "filePath": "docs/query/query-a-query.md",
      "url": "https://dune.com/docs/query/query-a-query.md",
      "summary": "# Query a Query\n\nThis section of the DuneSQL app technical guide explains how to query a query in DuneSQL. This feature allows users to create reusable queries, build up complex queries, and reuse queries as views.\n\n## Query queries as views in Dune SQL\n\nIn DuneSQL, all non-parameterized queries can be queried as views in other queries using the identifier `query_<queryId>`. For example, to query a query with ID 1234, the syntax would be:\n```\nselect * from query_1234\n```\nThe `queryId` is part of the URL of a query.\n\nIt is important to note that:\n- All output columns of the query being queried must be named. This means that queries like `select 1` or `select count(*) from ethereum.transactions` cannot be queried, but queries like `select 1 as v` and `select count(*) as total from ethereum.transactions` can be queried.\n- Parametrized queries are not supported.\n- Only public queries can be queried. Support for querying private queries will be added in the future.\n- Only saved queries can be queried.\n- Only queries written in Dune SQL can be queried.\n\nThe ability to query a query is useful for creating more complex queries and reusing queries as views. An example query is provided in the guide for reference.\n\nOverall, this section of the app technical guide provides a clear explanation of how to query a query in DuneSQL and the limitations of this feature. It is a useful reference for users who want to create more complex queries and reuse queries as views.",
      "questions": "1. What is DuneSQL and how does it relate to blockchain technology?\n- This app technical guide does not provide information on how DuneSQL relates to blockchain technology, so a blockchain SQL analyst might want to know more about the context and use cases of this tool.\n\n2. Can parameterized queries be queried as views in DuneSQL?\n- No, according to the app technical guide, only non-parameterized queries can be queried as views in DuneSQL.\n\n3. Is it possible to query private queries in DuneSQL?\n- No, the app technical guide states that only public queries can be queried as views in DuneSQL, and support for querying private queries will be added in the future."
    },
    {
      "fileName": "storage.md",
      "filePath": "docs/query/storage.md",
      "url": "https://dune.com/docs/query/storage.md",
      "summary": "# Storage\n\nThe Storage section of the Dune Docs app technical guide provides an overview of the differences and thinking behind the V2 database structure. The guide explains how databases read data from storage into memory to transform and return blockchain data according to Dune queries' logic. The guide focuses on the differences between row-oriented and column-oriented databases and how they affect query speed.\n\nThe guide starts by explaining how databases store data in pages, which traditionally contain rows of information. Multiple pages make one data file, and a table consists of one or more data files. The guide then explains how databases read data into memory by the page, and page size and the number of pages loaded are key bottlenecks for query speed. The guide explains that traditional databases store pages by row and are best suited for retrieving all columns of one row or data from multiple sequential rows. \n\nThe guide then explains that Dune V2 runs on column-oriented tables, which store data on AWS S3 using the parquet file format. The guide explains that parquet is a hybrid approach between row-oriented databases and column-oriented databases since a table still consists of multiple parquet files, which are themselves partitioned by rows. Inside the parquet files, the pages themselves contain columns instead of rows. The guide explains that the database is still roughly stored in a row-oriented format, but the individual values are stored in column orientation inside pages. \n\nThe guide then explains how the database uses min/max values to efficiently skip over entire parquet files or column chunks within parquet files while scanning through a table. The guide explains that the performance cost is mostly relevant for base tables like ethereum.transactions, bnb.logs, erc20_ethereum.erc20_evt_transfer, etc., which contain very large datasets that aren't pre-filtered. \n\nThe guide provides examples of Dune V2 queries and how they work. The first example queries for transaction hashes, and the guide explains how the query is inefficient because the only filter condition is a hash string. The guide explains that the query engine can skip a few column chunks where the min/max value stored in the parquet file footer is 0xa0 - 0xcd, but those will be a rare exception. The guide provides a more efficient query that filters by block number. \n\nThe guide also provides an example of aggregating data over a large amount of logical rows. The guide explains that this is mainly a case study to illustrate how efficient DuneV2 is in aggregating data over a large set of logical rows. \n\nThe guide concludes by stating that Dune will continue to innovate on these datasets and its database architecture to make every query run as fast as possible on V2. The guide encourages users to send feedback or identify areas of improvement to optimize the system.",
      "questions": "1. What is the difference between row-oriented and column-oriented databases, and why did Dune V2 choose to use a column-oriented approach?\n- Row-oriented databases store data in pages by row, while column-oriented databases store data in pages by column. Dune V2 chose to use a column-oriented approach because it is more efficient for querying data across a large amount of logical rows, which is common in blockchain systems.\n\n2. How does Dune V2 handle indexing, and what are the limitations of this approach?\n- Dune V2 uses the `min/max` values stored in the footer of each parquet file to efficiently skip over entire files or column chunks while scanning through a table. However, the `min/max` values of strings are oftentimes not very useful, which can make queries that reference them inefficient since all related pages will need to be read into memory.\n\n3. How does Dune V2 make querying for data across a large amount of logical rows more efficient?\n- Dune V2 stores data in column-oriented pages across parquet files, which allows it to read only the data that is actually needed for a query. This makes querying for data across a large amount of logical rows much more efficient and enables queries that were formerly impossible due to timing out."
    },
    {
      "fileName": "syntax-differences.md",
      "filePath": "docs/query/syntax-differences.md",
      "url": "https://dune.com/docs/query/syntax-differences.md",
      "summary": "The app technical guide provides a comprehensive guide for migrating queries from Postgres to Dune SQL and from SparkSQL to DuneSQL. The guide covers the syntax and operator differences between Postgres, Spark, and Dune SQL. It provides a detailed comparison of the syntax and keyword operator differences between the three databases. The guide explains the differences in syntax for various operations such as math or numeric operations, array-based indexing, implicit type conversions, addresses, selecting keyword columns, alias naming, exponentiation notation, interval argument, generate_series, handling decimals for prices.usd, defining NULL array, encoding strings to hex, get JSON object differences, group by an alias, explicit date/time casting, checking if an item exists in an array, explode, median, using “is True/False,” string data type, casting as strings, aggregate functions, user-generated views, and event logs topic indexing.\n\nThe guide provides examples for each of the syntax differences and explains how to use them in Dune SQL. It also highlights the differences in syntax between Dune SQL and other databases, such as Postgres and Spark SQL. The guide recommends avoiding the use of double quotes in Dune SQL, as the parser sometimes treats words in double quotes as a string and sometimes as an object like a column name.\n\nOverall, the app technical guide provides a comprehensive guide for migrating queries from Postgres and Spark SQL to Dune SQL. It is a valuable resource for developers who are new to Dune SQL and need to migrate their queries from other databases.",
      "questions": "1. What are the differences in handling decimals for prices.usd in Dune SQL compared to Postgres and Spark SQL?\n- In Dune SQL, decimals for prices.usd are replaced by tokens_[blockchain].erc20.decimals.\n\n2. How does Dune SQL handle implicit type conversions between character and numeric types compared to Postgres and Spark SQL?\n- Dune SQL does not have implicit type conversions between character and numeric types, unlike Postgres and Spark SQL.\n\n3. What is the recommended approach for using double quotes in Dune SQL?\n- Double quotes are not recommended in Dune SQL, as the parser sometimes treats words in double quotes as a string and sometimes as an object like a column name."
    }
  ],
  "folders": [
    {
      "folderName": "DuneSQL-reference",
      "folderPath": ".autodoc/docs/json/docs/query/DuneSQL-reference",
      "url": "https://dune.com/.autodoc/docs/json/docs/query/DuneSQL-reference",
      "files": [
        {
          "fileName": "index.md",
          "filePath": "docs/query/DuneSQL-reference/index.md",
          "url": "https://dune.com/docs/query/DuneSQL-reference/index.md",
          "summary": "# DuneSQL Overview\n\nThe DuneSQL Overview is a technical guide that provides an introduction to DuneSQL, a custom-built query engine optimized for blockchain data. The guide explains that DuneSQL is based on the open-source TrinoSQL engine and incorporates additional optimizations to handle blockchain-specific requirements. \n\n## Functions and Operators\n\nThis section of the guide covers the wide array of functions and operators that DuneSQL provides. These functions and operators enable users to perform various operations on their data, including arithmetic, string manipulation, date and time calculations, and much more. \n\nExample: `SELECT COUNT(*) FROM transactions WHERE block_number > 1000000;`\n\n## SQL Statement Syntax\n\nThe SQL Statement Syntax section explains that DuneSQL follows the standard SQL syntax, which consists of a series of clauses that define how data should be retrieved, manipulated, or stored. Commonly used clauses include SELECT, FROM, WHERE, GROUP BY, ORDER BY, and LIMIT. The guide also notes that administrative statements such as `create`, `update`, `delete`, and `drop` are disabled to ensure that the data in the database is not modified in any way. However, users can query queries in DuneSQL to replace the ability to create views and tables. \n\nExample: `SELECT * FROM transactions WHERE from_address = '0x123456789abcdef';`\n\n## SQL Language\n\nThe SQL Language section explains that the SQL language used in DuneSQL is ANSI-compliant, allowing users to leverage their existing SQL knowledge while working with blockchain data. Additionally, DuneSQL introduces custom data types and functions to better handle unique aspects of blockchain data, such as varbinary data types for addresses and hashes, as well as int256 and uint256 data types for large numeric values. \n\nExample: `SELECT COUNT(*) FROM transactions WHERE to_address = '0x987654321fedcba';`\n\nOverall, the DuneSQL Overview technical guide provides a comprehensive introduction to DuneSQL and its capabilities for efficient analysis of blockchain data.",
          "questions": "1. What optimizations has DuneSQL incorporated to handle blockchain-specific requirements?\n- DuneSQL has incorporated additional optimizations to handle blockchain-specific requirements.\n\n2. Can administrative statements such as create, update, delete, and drop be executed in DuneSQL?\n- No, all administrative statements are disabled in DuneSQL to ensure that the data in the database is not modified in any way.\n\n3. What custom data types and functions has DuneSQL introduced to better handle unique aspects of blockchain data?\n- DuneSQL has introduced custom data types and functions such as varbinary data types for addresses and hashes, as well as int256 and uint256 data types for large numeric values."
        }
      ],
      "folders": [
        {
          "folderName": "SQL-language",
          "folderPath": ".autodoc/docs/json/docs/query/DuneSQL-reference/SQL-language",
          "url": "https://dune.com/.autodoc/docs/json/docs/query/DuneSQL-reference/SQL-language",
          "files": [
            {
              "fileName": "datatypes.md",
              "filePath": "docs/query/DuneSQL-reference/SQL-language/datatypes.md",
              "url": "https://dune.com/docs/query/DuneSQL-reference/SQL-language/datatypes.md",
              "summary": "The app technical guide covers various data types used in DuneSQL, including:\n\n- **Boolean**: Captures boolean values `true` and `false`.\n- **Integer**: Different integer types such as `TINYINT`, `SMALLINT`, `INTEGER`, `BIGINT`, `UINT256`, and `INT256`.\n- **Floating-point**: `REAL` and `DOUBLE` types implementing the IEEE Standard 754 for Binary Floating-Point Arithmetic.\n- **Fixed-precision**: `DECIMAL` type with specified precision and scale.\n- **String**: `VARCHAR`, `CHAR`, `VARBINARY`, and `JSON` types.\n- **Date and time**: Various date and time types like `DATE`, `TIME`, `TIMESTAMP`, and `INTERVAL`.\n- **Structural**: `ARRAY`, `MAP`, and `ROW` types for complex data structures.\n- **Network address**: `IPADDRESS` type for IPv4 and IPv6 addresses.\n- **UUID**: Represents a Universally Unique IDentifier.\n- **HyperLogLog**: Data sketch for efficient computation of approximate distinct count.\n- **SetDigest**: Data sketch for calculating Jaccard similarity coefficient between two sets.\n- **Quantile digest**: Summary structure for capturing approximate distribution of data.\n- **T-Digest**: Summary structure similar to qdigest with higher performance, lower memory usage, and higher accuracy at high and low percentiles.\n\nThe guide provides examples and detailed explanations for each data type, including their usage, properties, and functions.",
              "questions": "1. **What are the differences between the `UINT256` and `INT256` data types, and when should each be used in EVM smart contracts?**\n\n   The `UINT256` data type is a 256-bit unsigned integer, representing only non-negative integers, including very large positive integers and zero. The `INT256` data type is a 256-bit signed integer, representing a wide range of values, including very large negative and positive integers, as well as zero. In EVM smart contracts, `UINT256` is commonly used for representing balances and other quantities, while `INT256` is used when the value can be negative.\n\n2. **How can I work with `VARBINARY` data types in DuneSQL, and are there any custom functions available for this purpose?**\n\n   In DuneSQL, addresses, hashes, calldata, and logs are stored as `VARBINARY` data types. You can use SQL statements with the binary data prefix `0x` and hexadecimal format for working with `VARBINARY` data types. DuneSQL also provides custom functions to make it easier to work with `VARBINARY` data types, which can be found on the [varbinary functions](/querying-with-DuneSQL/functions/varbinary/) page.\n\n3. **What are the differences between the `QDigest` and `TDigest` data structures, and when should each be used?**\n\n   Both `QDigest` and `TDigest` are summary structures that capture the approximate distribution of data for a given input set and can be queried to retrieve approximate quantile values. However, `TDigest` has some advantages over `QDigest`, including higher performance, lower memory usage, and higher accuracy at high and low percentiles. Both structures are additive, meaning they can be merged together without losing precision. You should choose the appropriate structure based on your performance, memory, and accuracy requirements."
            },
            {
              "fileName": "index.md",
              "filePath": "docs/query/DuneSQL-reference/SQL-language/index.md",
              "url": "https://dune.com/docs/query/DuneSQL-reference/SQL-language/index.md",
              "summary": "# Overview\n\nThe Overview section of the Dune Docs app technical guide provides an introduction to DuneSQL, a custom-built query engine optimized for blockchain data. DuneSQL is built on a fork of TrinoSQL, an ANSI SQL compliant query engine that allows users to integrate their favorite data tools with any underlying data source. \n\nThe section notes that DuneSQL validates and translates SQL statements into the necessary operations on the connected data source. It also provides a reference to the supported SQL data types and other general characteristics of the SQL support of DuneSQL. \n\nThe section includes links to a full SQL statement and syntax reference, as well as a reference to numerous SQL functions and operators provided by Trino. \n\nOverall, the Overview section serves as a high-level introduction to DuneSQL and its capabilities, providing context for the more detailed technical information provided in other sections of the app technical guide. \n\nExample: \n\nIf a user is new to DuneSQL and wants to understand its capabilities and how it differs from TrinoSQL, they can start by reading the Overview section. This will provide them with a basic understanding of DuneSQL's features and how it can be used with other data tools. They can then explore the other sections of the app technical guide for more detailed information on specific aspects of DuneSQL.",
              "questions": "1. What specific optimizations does DuneSQL have for blockchain data? \n- The app technical guide does not provide specific details on the optimizations made for blockchain data.\n\n2. Can DuneSQL connect to a blockchain database directly or does it require a separate data source? \n- The app technical guide does not provide information on whether DuneSQL can connect directly to a blockchain database or if it requires a separate data source.\n\n3. Are there any limitations or differences in the SQL data types supported by DuneSQL compared to TrinoSQL? \n- The app technical guide does not mention any limitations or differences in the SQL data types supported by DuneSQL compared to TrinoSQL."
            },
            {
              "fileName": "reserved.md",
              "filePath": "docs/query/DuneSQL-reference/SQL-language/reserved.md",
              "url": "https://dune.com/docs/query/DuneSQL-reference/SQL-language/reserved.md",
              "summary": "The \"Reserved Keywords\" section of the app technical guide for the Dune Docs project provides a comprehensive list of all the keywords that are reserved in Trino, along with their status in the SQL standard. These reserved keywords must be quoted (using double quotes) in order to be used as an identifier. \n\nThis section is important for developers who are working on the app feature that involves writing SQL queries. It is essential to know which keywords are reserved in Trino and must be quoted to avoid syntax errors. \n\nFor example, if a developer wants to use the keyword \"SELECT\" as a column name in a table, they must quote it as \"SELECT\" to avoid conflicts with the reserved keyword. \n\nThe table in this section lists all the reserved keywords in alphabetical order, along with their status in the SQL standard. The SQL standard status indicates whether the keyword is reserved or non-reserved in the standard. \n\nOverall, this section serves as a quick reference for developers working on the app feature that involves writing SQL queries. It helps them avoid syntax errors and ensures that their queries run smoothly.",
              "questions": "1. What is the purpose of the dune docs app?\n- The app technical guide provided does not give any information about the purpose of the dune docs app, so a blockchain SQL analyst might have this question.\n\n2. How does the dune docs app use SQL?\n- The app technical guide lists all the reserved keywords in Trino SQL, but it does not explain how the dune docs app uses SQL, so a blockchain SQL analyst might have this question.\n\n3. Are there any specific SQL features or functions that the dune docs app requires?\n- The app technical guide does not mention any specific SQL features or functions that the dune docs app requires, so a blockchain SQL analyst might have this question."
            },
            {
              "fileName": "sql-support.md",
              "filePath": "docs/query/DuneSQL-reference/SQL-language/sql-support.md",
              "url": "https://dune.com/docs/query/DuneSQL-reference/SQL-language/sql-support.md",
              "summary": "The SQL statement support section of the app technical guide in the dune docs project provides information on how to use SQL statements in the app. This section is located in the 'api' folder of the project. \n\nThe guide starts by explaining what SQL is and how it is used in the app. It then goes on to provide examples of SQL statements that can be used in the app, such as SELECT, INSERT, UPDATE, and DELETE. Each example is accompanied by a detailed explanation of what the statement does and how it can be used in the app.\n\nThe guide also covers how to use parameters in SQL statements, which allows for more dynamic and flexible queries. It provides examples of how to use parameters in SELECT, INSERT, and UPDATE statements.\n\nIn addition, the guide explains how to handle errors that may occur when using SQL statements in the app. It provides information on how to catch and handle errors using try-catch blocks.\n\nOverall, the SQL statement support section of the app technical guide is a comprehensive resource for developers who need to use SQL statements in the app. It provides clear explanations and examples of how to use SQL statements, as well as tips for handling errors that may occur.",
              "questions": "## Question 1\nWhat specific SQL statements does the app support?\n### Answer\nThe app technical guide does not provide information on the specific SQL statements supported. Further documentation or communication with the developers may be necessary to obtain this information.\n\n## Question 2\nDoes the app support any blockchain-specific SQL statements?\n### Answer\nThe app technical guide does not mention any blockchain-specific SQL statements. It is unclear if the app is designed for use with blockchain technology.\n\n## Question 3\nAre there any limitations or restrictions on the use of SQL statements within the app?\n### Answer\nThe app technical guide does not provide information on any limitations or restrictions on the use of SQL statements. Further documentation or communication with the developers may be necessary to obtain this information."
            }
          ],
          "folders": [],
          "summary": "The `.autodoc/docs/json/docs/query/DuneSQL-reference/SQL-language` folder contains a comprehensive guide on various aspects of DuneSQL, a custom-built query engine optimized for blockchain data. This guide is essential for developers and analysts working on the app feature that involves writing SQL queries and understanding the data types supported by DuneSQL.\n\nThe `datatypes.md` file provides an in-depth explanation of the various data types used in DuneSQL, such as Boolean, Integer, Floating-point, Fixed-precision, String, Date and time, Structural, Network address, UUID, HyperLogLog, SetDigest, Quantile digest, and T-Digest. This guide is useful for developers who need to understand the properties and functions of each data type when designing database schemas or writing SQL queries.\n\nThe `index.md` file serves as an overview of DuneSQL, its capabilities, and how it differs from TrinoSQL. This high-level introduction is beneficial for users who are new to DuneSQL and want to understand its features and integration with other data tools.\n\nThe `reserved.md` file lists all the reserved keywords in Trino, along with their status in the SQL standard. This section is crucial for developers to avoid syntax errors when writing SQL queries by quoting reserved keywords.\n\nThe `sql-support.md` file offers a detailed guide on using SQL statements in the app, including examples of SELECT, INSERT, UPDATE, and DELETE statements. It also covers the use of parameters in SQL statements for more dynamic and flexible queries and provides tips on handling errors that may occur.\n\nFor example, a developer working on a feature that requires querying blockchain data can refer to the `datatypes.md` file to understand the appropriate data types to use in their queries. They can also consult the `sql-support.md` file for examples of SQL statements and how to use parameters for more dynamic queries. If they encounter a reserved keyword in their query, they can refer to the `reserved.md` file to ensure they quote it correctly to avoid syntax errors.\n\nOverall, the guide in this folder is an essential resource for developers and analysts working on the app feature that involves writing SQL queries and understanding the data types supported by DuneSQL. It provides clear explanations, examples, and tips to ensure smooth and efficient querying of blockchain data.",
          "questions": ""
        }
      ],
      "summary": "The `.autodoc/docs/json/docs/query/DuneSQL-reference` folder contains a technical guide focused on DuneSQL, a custom-built query engine optimized for blockchain data. This guide is essential for developers and analysts working on the app feature that involves writing SQL queries and understanding the data types supported by DuneSQL.\n\nThe `index.md` file provides an overview of DuneSQL, its capabilities, and how it differs from TrinoSQL. It covers the wide array of functions and operators that DuneSQL provides, such as arithmetic, string manipulation, date and time calculations, and more. It also explains that DuneSQL follows the standard SQL syntax and is ANSI-compliant, allowing users to leverage their existing SQL knowledge while working with blockchain data.\n\nFor example, a developer working on a feature that requires querying blockchain data can refer to the `index.md` file to understand the basic syntax and capabilities of DuneSQL:\n\n```\nSELECT COUNT(*) FROM transactions WHERE block_number > 1000000;\n```\n\nThe `SQL-language` subfolder contains a comprehensive guide on various aspects of DuneSQL. The `datatypes.md` file provides an in-depth explanation of the various data types used in DuneSQL, such as Boolean, Integer, Floating-point, Fixed-precision, String, Date and time, Structural, Network address, UUID, HyperLogLog, SetDigest, Quantile digest, and T-Digest. This guide is useful for developers who need to understand the properties and functions of each data type when designing database schemas or writing SQL queries.\n\nFor example, a developer working on a feature that requires querying blockchain data can refer to the `datatypes.md` file to understand the appropriate data types to use in their queries:\n\n```\nSELECT COUNT(*) FROM transactions WHERE to_address = '0x987654321fedcba';\n```\n\nThe `reserved.md` file lists all the reserved keywords in Trino, along with their status in the SQL standard. This section is crucial for developers to avoid syntax errors when writing SQL queries by quoting reserved keywords.\n\nThe `sql-support.md` file offers a detailed guide on using SQL statements in the app, including examples of SELECT, INSERT, UPDATE, and DELETE statements. It also covers the use of parameters in SQL statements for more dynamic and flexible queries and provides tips on handling errors that may occur.\n\nOverall, the guide in this folder is an essential resource for developers and analysts working on the app feature that involves writing SQL queries and understanding the data types supported by DuneSQL. It provides clear explanations, examples, and tips to ensure smooth and efficient querying of blockchain data.",
      "questions": ""
    }
  ],
  "summary": "The `.autodoc/docs/json/docs/query` folder contains a technical guide focused on DuneSQL, a custom-built query engine optimized for blockchain data analysis. This guide is essential for developers and analysts working on app features that involve writing SQL queries and understanding the data types supported by DuneSQL.\n\nFor example, a developer working on a feature that requires querying blockchain data can refer to the `dunesql-changes.md` file to understand the migration changes that occurred on March 2nd, 2023, and how to adjust their queries accordingly. The guide provides examples of queries that need to be adjusted and common errors that users may encounter.\n\nThe `index.md` file provides an overview of DuneSQL, its features, and how it differs from TrinoSQL. It covers the wide array of functions and operators that DuneSQL provides, such as arithmetic, string manipulation, date and time calculations, and more. It also explains that DuneSQL follows the standard SQL syntax and is ANSI-compliant, allowing users to leverage their existing SQL knowledge while working with blockchain data.\n\nThe `query-a-query.md` file explains how to query a query in DuneSQL, allowing users to create reusable queries, build up complex queries, and reuse queries as views. This feature is useful for creating more complex queries and reusing queries as views. An example query is provided in the guide for reference.\n\nThe `storage.md` file provides an overview of the differences and thinking behind the V2 database structure, focusing on the differences between row-oriented and column-oriented databases and how they affect query speed. The guide provides examples of Dune V2 queries and how they work, as well as tips for optimizing query performance.\n\nThe `syntax-differences.md` file provides a comprehensive guide for migrating queries from Postgres and Spark SQL to Dune SQL. It is a valuable resource for developers who are new to Dune SQL and need to migrate their queries from other databases.\n\nThe `DuneSQL-reference` subfolder contains a comprehensive guide on various aspects of DuneSQL, such as data types, reserved keywords, and SQL statement support. This guide is useful for developers who need to understand the properties and functions of each data type when designing database schemas or writing SQL queries.\n\nOverall, the guide in this folder is an essential resource for developers and analysts working on app features that involve writing SQL queries and understanding the data types supported by DuneSQL. It provides clear explanations, examples, and tips to ensure smooth and efficient querying of blockchain data.",
  "questions": ""
}