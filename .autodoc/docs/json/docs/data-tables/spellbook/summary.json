{
  "folderName": "spellbook",
  "folderPath": "docs/data-tables/spellbook",
  "url": "https://dune.com/docs/data-tables/spellbook",
  "files": [
    {
      "fileName": "index.md",
      "filePath": "docs/data-tables/spellbook/index.md",
      "url": "https://dune.com/docs/data-tables/spellbook/index.md",
      "summary": "The app technical guide covers the topic of Spells, which are custom tables constructed and maintained by Dune and the community. The guide explains that Spells are available on Dune V2 and can be queried from both Spark SQL and Dune SQL V2 Query Engines. The guide also provides a link to the Spellbook GitHub repository, where all the Spellbook Spell tables can be found. \n\nThe guide then introduces the new Spellbook, which is a retooling of the existing abstractions repository and a first-in-class open-source analytics engineering tool called dbt. The guide explains that dbt allows for the writing and management of unit tests to spot and prevent any issues in abstractions. It also allows for data integrity tests to be added with a single line in a YAML file. The guide highlights that dbt natively understands the dependencies between all models, which makes deploying and maintaining them easier. \n\nThe guide then goes on to explain Sector Spells, which are tables that take in data from multiple contracts and projects, standardize the data across them, and make it easy to query for this data and compare the metrics of different projects with each other. The guide notes that most of the sector dashboards depend on sector spells and that projects can easily get their data into these dashboards by making a pull request to the public GitHub repo. \n\nThe guide also explains Project Spells, which allow projects to assemble their data into one neat table that has all the data they need in one place. The main advantage of using Spells over just constructing a view is that Spells can deal with bigger amounts of data since they can run automatically in the background every few hours. \n\nFinally, the guide provides information on how to contribute to Spellbook and how to view available Spells. It notes that Spells are managed via the public Spellbook GitHub repository and that pull requests are welcome. The guide also provides a warning that the abstractions for V1 are no longer open for contributions and will be sunsetted with the V1 engine soon. \n\nOverall, the app technical guide provides a comprehensive overview of Spells, the Spellbook, and how to contribute to Spellbook. It is a useful resource for anyone looking to understand how to use Spells and how to contribute to the Spellbook project.",
      "questions": "1. What is the purpose of Spells in Dune and how are they maintained?\n- Spells are custom tables that cover a type of activity on the blockchain and are built and maintained by Dune and their community.\n\n2. What is the difference between Sector Spells and Project Spells?\n- Sector Spells standardize data from multiple contracts and projects, making it easy to query and compare metrics, while Project Spells allow projects to assemble their data into one table and deal with larger amounts of data automatically.\n\n3. What is dbt and how does it improve the process of creating Spells?\n- dbt is an open-source analytics engineering tool that injects classical software engineering practices into writing SQL, allowing for the creation and management of unit tests and easy addition of data integrity tests. It also understands the dependencies between all models, making deploying and maintaining Spells more efficient."
    }
  ],
  "folders": [
    {
      "folderName": "contributing",
      "folderPath": "docs/data-tables/spellbook/contributing",
      "url": "https://dune.com/docs/data-tables/spellbook/contributing",
      "files": [
        {
          "fileName": "index.md",
          "filePath": "docs/data-tables/spellbook/contributing/index.md",
          "url": "https://dune.com/docs/data-tables/spellbook/contributing/index.md",
          "summary": "# Spellbook Technical Guide\n\nThis technical guide is focused on the Spellbook feature of the Dune Docs project. The Spellbook is a collection of how-to guides for creating and using Spells, which are essentially SQL queries that can be saved and reused. \n\n## Casting a Spell from scratch\n\nThis section provides a link to a guide on how to add a Spell to the Spellbook. The guide is located in the `contributing/Adding A Spell` folder and is intended for users who want to learn by doing. The guide provides step-by-step instructions on how to create a new Spell and add it to the Spellbook.\n\n## Spellbook on GitHub\n\nThis section provides a link to the Spellbook repository on GitHub. Users who want to take a look under the hood can find the source code for the Spellbook here. The repository contains a variety of how-to guides for creating Spells.\n\n## Video Guides\n\nThis section provides links to two video guides on how to use the Spellbook. The first video is a DuneCon workshop presented by Megan Heintz, a member of the Dune Team who came up with the name \"Spellbook\". The workshop provides an overview of the Spellbook's infrastructure and demonstrates how to migrate data to a Spell. The second video is a tutorial presented by Andrew Hong, who shows how to create a pair, manage liquidity, swap through pairs, and pull and transform data on Ethereum using Spells.\n\nOverall, this technical guide provides users with resources for learning how to use the Spellbook feature of the Dune Docs project. Users can follow step-by-step guides, explore the source code on GitHub, or watch video tutorials to learn how to create and use Spells.",
          "questions": "1. What is the purpose of the Spellbook app and how does it relate to blockchain technology?\n    \n    The app technical guide does not provide clear information on the purpose of the Spellbook app or its relation to blockchain technology, so a blockchain SQL analyst might have to do further research or seek clarification from the developers.\n\n2. Are there any security measures in place to protect user data and transactions within the app?\n\n    The app technical guide does not mention any security measures in place to protect user data and transactions, so a blockchain SQL analyst might have to investigate further or consult with the developers to ensure the app is secure.\n\n3. What programming languages and frameworks were used to develop the Spellbook app?\n\n    The app technical guide does not provide information on the programming languages and frameworks used to develop the Spellbook app, so a blockchain SQL analyst might have to do further research or consult with the developers to determine the technology stack."
        }
      ],
      "folders": [
        {
          "folderName": "Adding A Spell",
          "folderPath": "docs/data-tables/spellbook/contributing/Adding A Spell",
          "url": "https://dune.com/docs/data-tables/spellbook/contributing/Adding A Spell",
          "files": [
            {
              "fileName": "1-do-some-prerequisites and-set-up-Spellbook-dbt.md",
              "filePath": "docs/data-tables/spellbook/contributing/Adding A Spell/1-do-some-prerequisites and-set-up-Spellbook-dbt.md",
              "url": "https://dune.com/docs/data-tables/spellbook/contributing/Adding A Spell/1-do-some-prerequisites and-set-up-Spellbook-dbt.md",
              "summary": "This technical guide provides instructions on how to set up Spellbook dbt on a local computer. The guide is divided into two main sections: prerequisites and setting up Spellbook dbt. \n\nThe prerequisites section outlines the software and tools required to set up Spellbook dbt. These include VSCode, Python 3.9, pip, pipenv, git, and GitHub. The guide provides links to download and install each of these tools. Additionally, the guide instructs users to fork the Spellbook repository, clone it locally, and add an upstream. The guide also includes a video tutorial on how to fork the Spellbook repo.\n\nThe second section of the guide focuses on setting up Spellbook dbt. Once the user has a local copy of their Spellbook fork, they need to install the necessary packages by running `pipenv install` in the terminal. The guide then instructs users to activate their virtual environment by running `pipenv shell` and initialize dbt by running `dbt init`. The guide provides a list of prompts that users should enter when initializing dbt. The guide also instructs users to run `dbt deps` to install dependencies and `dbt compile` to compile the project. Finally, the guide instructs users to create a new branch called \"workshop\" and push it to their remote GitHub repository.\n\nOverall, this guide provides detailed instructions on how to set up Spellbook dbt on a local computer. The guide is well-structured and includes links to relevant resources and a video tutorial. The guide is intended for users who are new to Spellbook dbt and provides step-by-step instructions to ensure that users can set up Spellbook dbt without any issues.",
              "questions": "1. What is the purpose of Spellbook and how does it relate to blockchain technology?\n- The app technical guide does not provide information on the purpose of Spellbook or its relation to blockchain technology.\n\n2. Are there any specific SQL databases that Spellbook dbt is compatible with?\n- The app technical guide does not provide information on the specific SQL databases that Spellbook dbt is compatible with.\n\n3. Is there any guidance on how to integrate Spellbook with a blockchain network or smart contract?\n- The app technical guide does not provide information on how to integrate Spellbook with a blockchain network or smart contract."
            },
            {
              "fileName": "2-decide-on-a-Spell-to-cast.md",
              "filePath": "docs/data-tables/spellbook/contributing/Adding A Spell/2-decide-on-a-Spell-to-cast.md",
              "url": "https://dune.com/docs/data-tables/spellbook/contributing/Adding A Spell/2-decide-on-a-Spell-to-cast.md",
              "summary": "This app technical guide covers the process of deciding on a Spell to cast in the Dune app. The guide provides three ways to decide on a Spell, including having an idea based on previous experience with Dune, checking out Spellbook bounties in Dework, or asking for suggestions in the #spellbook Discord channel. \n\nThe guide then provides an example of creating a migration Spell, specifically translating the Keep3r network `view_job_log` abstraction from Dune's v1 database into a V2 Spell. The guide directs the user to find the `view_job_log.sql` file in the `deprecated-dune-v1-abstractions` folder within VSCode. \n\nThe guide also includes a note that Dune V1 Abstractions have been moved to a new repository and provides a link to access the code for migrating a V1 Abstraction to a Spell. The guide concludes by instructing the user to set up the file structure for the Spell's SQL schema and source files.\n\nOverall, this guide provides a clear and concise explanation of how to decide on a Spell and create a migration Spell in the Dune app. The example provided helps to illustrate the process and make it more accessible to users.",
              "questions": "1. What is the purpose of the Dune Docs app and how does it relate to blockchain technology?\n- The app technical guide does not provide information on the purpose of the Dune Docs app or its relation to blockchain technology.\n\n2. What is the significance of the migration Spell mentioned in the guide?\n- The migration Spell mentioned in the guide is for translating the Keep3r network `view_job_log` abstraction from Dune’s v1 database into a V2 Spell.\n\n3. How does the Spellbook bounties in Dework relate to blockchain SQL analysis?\n- The Spellbook bounties in Dework provide a way for users to suggest and work on Spells, which may involve SQL analysis related to blockchain technology."
            },
            {
              "fileName": "3-set-up-your-file-structure-for-SQL-schema-and-source-files.md",
              "filePath": "docs/data-tables/spellbook/contributing/Adding A Spell/3-set-up-your-file-structure-for-SQL-schema-and-source-files.md",
              "url": "https://dune.com/docs/data-tables/spellbook/contributing/Adding A Spell/3-set-up-your-file-structure-for-SQL-schema-and-source-files.md",
              "summary": "This app technical guide provides instructions on how to set up the file structure for SQL, schema, and source files in the Dune Docs project. The guide explains that all Spells are stored in the `/spellbook/models` directory by project name, then blockchain network. The folder names are all lowercase, and words are separated by underscores. The guide provides an example of the folder structure for the Keep3r network, where the folder is `/spellbook/models/keep3r_network/ethereum`. \n\nThe guide explains that if the project folder exists but a Spell is being created for a new blockchain, a folder for the new blockchain should be created. The guide then explains that three files need to be created: a `.sql` file for the Spell's logic, a `_schema.yml` file to define the Spell's purpose and add generic tests, descriptions, metadata, etc., and a `_sources.yml` file with any project-specific table dependencies. The guide provides an example of the file structure for a Spell folder.\n\nThe guide also explains the naming convention for Spell files. Schema files are named `[project_name]_[blockchain]_schema.yml`, sources files are named `[project_name]_[blockchain]_sources.yml`, and SQL files for Spells are named `[project_name]_[blockchain]_[spell_name].sql`. \n\nThe guide then provides an example of a specific v1 migration example where three additional `.sql` files are needed for a Spell called `keep3r_network_ethereum_view_job_log.sql`. The guide explains that these files are needed because the original `view_job_log.sql` V1 Abstraction has two `FROM` statements that reference two other files that are also abstractions that need to be converted into Spells. The guide also explains that a recursive check needs to be done to see if those abstractions depend on any other abstractions that have yet to be migrated to Spells. \n\nOverall, this app technical guide provides a detailed explanation of how to set up the file structure for Spells in the Dune Docs project and provides examples to help users understand the process.",
              "questions": "1. What is the purpose of the dune docs app and how does it relate to blockchain SQL analysis?\n- The app technical guide does not provide information on the purpose of the dune docs app or its relation to blockchain SQL analysis.\n\n2. What is the file structure for storing Spells in the dune docs app?\n- Spells are stored in the `/spellbook/models` directory by project name, then blockchain network. Names are all lower case and words are separated by `_`. The app requires the creation of three files: a `.sql` file for the Spell's logic, a `_schema.yml` file for defining the spell's purpose and adding metadata, and a `_sources.yml` file for project-specific table dependencies.\n\n3. How does the app handle dependencies between Spells and abstractions in the migration process?\n- The app requires a recursive check to see if abstractions depend on any other abstractions that have yet to be migrated to Spells. The app also requires the creation of additional `.sql` files for Spells that depend on other abstractions, and these dependencies are identified by searching for `FROM` statements in the original abstractions."
            },
            {
              "fileName": "4-identify-and-define-sources.md",
              "filePath": "docs/data-tables/spellbook/contributing/Adding A Spell/4-identify-and-define-sources.md",
              "url": "https://dune.com/docs/data-tables/spellbook/contributing/Adding A Spell/4-identify-and-define-sources.md",
              "summary": "# App Technical Guide: Identify and Define Sources\n\nThis guide is focused on the `app` folder of the Dune Docs project and covers the process of identifying and defining sources in the `_sources.yml` file. The purpose of this file is to provide a structured way of defining the sources of data that will be used in the project. \n\nThe guide provides an example of how to format the `_sources.yml` file, which includes a version number and a list of sources. Each source is defined by a name, a one-line description, and a list of tables. The guide also explains how to identify the sources that need to be named by searching for `FROM` statements in the V1 abstractions that are being migrated. \n\nThe example provided in the guide is for the Keep3r Network Ethereum sources. The name of the source is `keep3r_network_ethereum`, and the description provides an overview of the Keep3r Network and its purpose. The list of tables includes the names of the tables that will be used as sources of data for the project. \n\nOverall, this guide is a useful resource for developers who are working on the Dune Docs project and need to identify and define sources of data. By following the guidelines provided in this guide, developers can ensure that the sources of data are properly defined and structured, which will make it easier to work with the data in the project.",
              "questions": "1. What is the purpose of the `_sources.yml` file in the Dune Docs project?\n    \n    The `_sources.yml` file in the Dune Docs project is used to define sources, including their names, descriptions, and tables.\n\n2. How are the sources formatted in the `_sources.yml` file?\n    \n    The sources in the `_sources.yml` file are formatted using YAML syntax, with a version number and a list of sources that include a name, description, and tables.\n\n3. How does one determine which tables to include in the `_sources.yml` file?\n    \n    To determine which tables to include in the `_sources.yml` file, one should search for `FROM` statements in the V1 abstractions being migrated and include all tables mentioned that are not abstractions."
            },
            {
              "fileName": "6-write-your-spell-as-SELECT-statement.md",
              "filePath": "docs/data-tables/spellbook/contributing/Adding A Spell/6-write-your-spell-as-SELECT-statement.md",
              "url": "https://dune.com/docs/data-tables/spellbook/contributing/Adding A Spell/6-write-your-spell-as-SELECT-statement.md",
              "summary": "This technical guide covers the process of writing a Spell as a SELECT statement in the Dune Docs project. The guide is focused on the app folder of the project. The guide starts by explaining that the endpoint is `_view_job_log.sql`, but the process should start with `_view_job_migrations.sql` because it is the lowest-level dependency. The guide then explains how to migrate from V1 abstraction to V2 Spell by copying the contents of the V1 file to the `keep3r_network_ethereum_view_job_migrations.sql` file. The guide explains that the `CREATE` or `REPLACE` definition statement is not needed, and everything from the first `SELECT` to the last `TRUE` is required. The guide then explains how to replace hard-coded references with JINJA templating. \n\nThe guide provides examples of SQL code and explains how to modify the syntax to V2/Spark SQL. The guide also explains how to replace hard-coded references with JINJA templating. The guide provides examples of how to format references to sources and models using JINJA. The guide emphasizes the need to test the SQL code in dune.com and fix any errors. The guide also provides tips on how to fix errors by googling or asking for help in the community's Discord channel. \n\nIn summary, this technical guide provides a step-by-step process of writing a Spell as a SELECT statement in the Dune Docs project. The guide covers how to migrate from V1 abstraction to V2 Spell, how to replace hard-coded references with JINJA templating, and how to test the SQL code and fix errors.",
              "questions": "1. What is the purpose of the dune docs app?\n- The app technical guide does not provide information on the purpose of the dune docs app.\n\n2. What programming languages or technologies are used in this app?\n- The app technical guide mentions the use of SQL, PostgreSQL, Spark SQL, and JINJA templating.\n\n3. What is the process for migrating from V1 abstraction to V2 Spell style?\n- The app technical guide provides a detailed process for migrating from V1 abstraction to V2 Spell style, including modifying syntax to Spark SQL, replacing hard-coded references with JINJA templating, and testing individual SQL files in dune.com."
            },
            {
              "fileName": "7-configure-alias-and-materialization-strategy.md",
              "filePath": "docs/data-tables/spellbook/contributing/Adding A Spell/7-configure-alias-and-materialization-strategy.md",
              "url": "https://dune.com/docs/data-tables/spellbook/contributing/Adding A Spell/7-configure-alias-and-materialization-strategy.md",
              "summary": "This app technical guide covers the configuration of aliases and materialization strategies in the Spellbook project. The guide explains that materialization strategies are used to persist data in the data lake house and there are four materialization strategies in dbt: table, ephemeral, view, and incremental. Spellbook uses view and incremental strategies. \n\nThe guide explains that view Spells are rebuilt each time they are run, meaning every time someone queries a view Spell, the SQL is run, and fresh data is gathered according to the Spell’s SQL logic. On the other hand, incremental Spells allow dbt to insert or update records in a table according to the logic defined. The guide provides an example of how to create an incremental Spell by including a statement of which column to join new data to the existing data each time the Spell is incremented.\n\nThe guide also explains how to configure aliases and materialization. To configure a Spell’s alias and materialization, the configuration is added to the top of each SQL file. The configuration includes creating an alias for the Spell file that will appear in the dune.com UI, defining how the file is stored and categorized in the UI, and naming the contributors. The guide provides an example of how to configure a Spell’s alias and materialization using a view materialization strategy.\n\nFinally, the guide explains how to add new models to the dbt_project.yml file in the Spellbook root folder. The guide provides an example of how to specify the project name, schema, and materialization strategy for the project as a whole as well as the specific blockchain(s) that Spells have been created for. \n\nOverall, this guide provides a detailed explanation of how to configure aliases and materialization strategies in the Spellbook project. It is a useful resource for developers working on the project who need to configure aliases and materialization strategies for their Spells.",
              "questions": "1. What are the available materialization strategies in dbt and which ones does Spellbook use?\n- The available materialization strategies in dbt are `table`, `ephemeral`, `view`, and `incremental`. Spellbook uses `view` and `incremental`.\n\n2. How does the `incremental` materialization strategy work and what configuration is needed to implement it?\n- The `incremental` materialization strategy allows dbt to insert or update records in a table according to the logic defined. To implement it, the configuration section of the file needs to include a statement of which column to join new data to existing data, specify that it is an incremental Spell, and provide an instruction for how dbt should combine new/old data using `merge`. Additionally, `if` statements need to be added to any `FROM` for which data needs to be incremented.\n\n3. How do you configure a Spell's alias and materialization and where is this configuration added?\n- To configure a Spell's alias and materialization, the configuration is added to the top of each SQL file. The configuration includes creating an alias for the Spell file that will appear in the UI, defining how the file is stored and categorized in the UI, and specifying whether it is a Spell for a specific project or a whole sector. This configuration assumes the use of a `view` materialization strategy."
            },
            {
              "fileName": "8-make-a-pull-request-get-merged-become-an-archwizard.md",
              "filePath": "docs/data-tables/spellbook/contributing/Adding A Spell/8-make-a-pull-request-get-merged-become-an-archwizard.md",
              "url": "https://dune.com/docs/data-tables/spellbook/contributing/Adding A Spell/8-make-a-pull-request-get-merged-become-an-archwizard.md",
              "summary": "This section of the app technical guide covers the process of making a pull request to the official Spellbook in the Dune Docs project. The guide provides step-by-step instructions on how to submit a pull request after committing local changes to the Spellbook GitHub fork. The guide also emphasizes the importance of giving an appropriate message when submitting a pull request and waiting for comments from the team. \n\nThe guide includes an example of the \"Open pull request button\" and encourages users to address any comments from the team before their Spell is approved. The ultimate goal of this section is to guide users towards becoming a Dune Archwizard by having their Spell approved. \n\nOverall, this section of the guide is focused on the app feature of contributing to the official Spellbook and becoming a part of the select few Dune Archwizards. It provides clear instructions and encourages users to take the necessary steps to ensure their pull request is approved.",
              "questions": "1. What is the purpose of the Dune Docs project and how does it relate to blockchain technology?\n- The app technical guide does not provide information on the purpose of the Dune Docs project or its relation to blockchain technology.\n\n2. What programming languages or frameworks are used in the development of this app?\n- The app technical guide does not provide information on the programming languages or frameworks used in the development of this app.\n\n3. Are there any security measures in place to protect user data or prevent unauthorized access?\n- The app technical guide does not provide information on any security measures in place to protect user data or prevent unauthorized access."
            },
            {
              "fileName": "index.md",
              "filePath": "docs/data-tables/spellbook/contributing/Adding A Spell/index.md",
              "url": "https://dune.com/docs/data-tables/spellbook/contributing/Adding A Spell/index.md",
              "summary": "The app technical guide provides a comprehensive explanation of Spellbook, an open-source dbt repository for creating and maintaining high-level blockchain data tables using SQL and Jinja templating. The guide explains how Spellbook enables the community to build towards a standardized way to transform data into meaningful abstraction layers. The guide also highlights the importance of Spellbook in making blockchain data more transparent, accessible, and meaningful together. \n\nThe guide provides a step-by-step process of how to cast a Spell, which includes setting up Spellbook dbt, deciding on a Spell to cast, setting up a file structure for SQL, schema, and source files, identifying and defining sources, defining expectations with schema and tests, writing a Spell as a SELECT statement, configuring alias and materialization strategy, and making a pull request to become an Archwizard. \n\nThe guide also provides examples of how to use Spellbook to aggregate and organize raw data from multiple sources to make it much easier to query. For instance, the nft.trades Spell enables users to see industry-wide stats like total volume by # of txs and $USD, 24-hr volume, 24-hour and 7-day growth, market share by marketplace, volume by marketplace, and transaction count by marketplace. \n\nOverall, the app technical guide provides a detailed explanation of Spellbook and how to cast a Spell, making it easier for users to create and maintain high-level blockchain data tables using SQL and Jinja templating.",
              "questions": "1. What is Spellbook and how does it relate to blockchain data analytics?\n- Spellbook is an open-source dbt repository for creating and maintaining high-level blockchain data tables using SQL and Jinja templating. It enables the community to build toward a standardized way to transform data into meaningful abstraction layers, making it much easier to query blockchain data.\n\n2. How does Spellbook save time and effort in blockchain data analysis?\n- Spellbook allows users to create abstracted data sets, like dex.trades and nft.trades, which aggregate and organize raw data from multiple sources. This saves time and effort in data analysis as users can skip the manual abstraction work and get straight to the insights.\n\n3. How can a blockchain SQL analyst contribute to Spellbook?\n- A blockchain SQL analyst can contribute to Spellbook by doing the data engineering for a new marketplace, submitting a Pull Request to Spellbook, and having the entire community benefit from their work. They can also follow the 8 steps outlined in the app technical guide to create and maintain high-level blockchain data tables using SQL and Jinja templating."
            }
          ],
          "folders": [],
          "summary": "This folder in the Dune Docs project focuses on the process of contributing a new Spell to the Spellbook, which is an open-source dbt repository for creating and maintaining high-level blockchain data tables using SQL and Jinja templating. The guides in this folder provide detailed instructions on how to set up Spellbook dbt, decide on a Spell to cast, set up a file structure for SQL, schema, and source files, identify and define sources, define expectations with schema and tests, write a Spell as a SELECT statement, configure alias and materialization strategy, and make a pull request to become an Archwizard.\n\nFor example, the guide \"2-decide-on-a-Spell-to-cast.md\" helps users decide on a Spell to cast by providing three ways to decide on a Spell, including having an idea based on previous experience with Dune, checking out Spellbook bounties in Dework, or asking for suggestions in the #spellbook Discord channel. The guide also provides an example of creating a migration Spell, specifically translating the Keep3r network `view_job_log` abstraction from Dune's v1 database into a V2 Spell.\n\nAnother example is the guide \"6-write-your-spell-as-SELECT-statement.md\", which covers the process of writing a Spell as a SELECT statement in the Dune Docs project. The guide provides a step-by-step process of migrating from V1 abstraction to V2 Spell, replacing hard-coded references with JINJA templating, and testing the SQL code and fixing errors.\n\nThese guides are useful for analysts and developers who want to contribute to the Spellbook project by creating and maintaining high-level blockchain data tables. By following the instructions provided in these guides, users can ensure that their Spells are properly structured, tested, and integrated into the Spellbook project. This will ultimately help make blockchain data more transparent, accessible, and meaningful for the entire community.\n\nOverall, the guides in this folder provide a comprehensive explanation of how to contribute a new Spell to the Spellbook project, making it easier for users to create and maintain high-level blockchain data tables using SQL and Jinja templating. The guides are well-structured and include examples to help users understand the process and contribute effectively to the project.",
          "questions": ""
        },
        {
          "folderName": "examples",
          "folderPath": "docs/data-tables/spellbook/contributing/examples",
          "url": "https://dune.com/docs/data-tables/spellbook/contributing/examples",
          "files": [
            {
              "fileName": "daily-aggregation.md",
              "filePath": "docs/data-tables/spellbook/contributing/examples/daily-aggregation.md",
              "url": "https://dune.com/docs/data-tables/spellbook/contributing/examples/daily-aggregation.md",
              "summary": "# Daily Aggregation\n\nThis section of the app technical guide covers the daily aggregation feature of the Dune Docs project. The purpose of this feature is to sum all transfers for the day. The table is materialized as an incrementally loaded table updated every 15 minutes because the next step includes a slower `[window](https://spark.apache.org/docs/latest/sql-ref-syntax-qry-select-window.html)` function to capture a rolling sum.\n\nThe guide explains the novel components that make this Spell incremental. The `<div data-gb-custom-block data-tag=\"if\"> </div>` JINJA block allows the addition of an arbitrary filter when running in “incremental” mode. Incremental mode is default and a full refresh is denoted by a command line arg to completely recreate the table. The block is used to filter for all data timestamped in the last two days. The model runs every fifteen minutes, but a look back of 2 days is allowed to account for data arriving late from the blockchain.\n\nTo avoid duplicates, a “`merge`” incremental\\_strategy is used. Merge strategies require a unique key and deduplicate the table upon each update. The guide shows that a unique key is created by coalescing several transfer features together that are utilized here.\n\nThe guide also introduces the first use of “refs” in this spellset. A ref, like `{{ ref('tokens_ethereum_erc20') }}` is simply a reference to another model in the DBT project. The ref references the name of the file itself. That means, duplicate file names cannot exist.\n\nThe guide provides an example of the `transfers_ethereum_erc20_agg_day.sql` file, which contains the SQL code for the daily aggregation feature. The code includes a configuration block that specifies the alias, materialized, file format, incremental strategy, and unique key. The SQL code also includes a select statement that retrieves the required data and a group by statement that groups the data by the required fields.\n\nThe guide also provides an example of the `transfers_ethereum_schema.yml` file, which contains the schema for the Ethereum transfers. The schema includes the name of the transfer, the blockchain, the sector, the project, the contributors, the tags, and the columns. The columns include the blockchain, the hour, the wallet address, the token address, the symbol, the amount raw, and the amount USD.\n\nIn summary, this section of the app technical guide provides a detailed explanation of the daily aggregation feature of the Dune Docs project. It explains the novel components that make this Spell incremental, provides examples of the SQL code and schema files, and introduces the concept of refs.",
              "questions": "1. What is the purpose of the Daily Aggregation table in the Dune Docs app?\n- The Daily Aggregation table sums all transfers for the day and is materialized as an incrementally loaded table updated every 15 minutes.\n\n2. How does the app handle duplicates in the Daily Aggregation table?\n- The app uses a \"merge\" incremental strategy that requires a unique key and deduplicates the table upon each update.\n\n3. What is a ref in the Dune Docs app and how is it used?\n- A ref is a reference to another model in the DBT project and is used to reference the name of the file itself. It cannot have duplicate file names."
            },
            {
              "fileName": "final-day-balance.md",
              "filePath": "docs/data-tables/spellbook/contributing/examples/final-day-balance.md",
              "url": "https://dune.com/docs/data-tables/spellbook/contributing/examples/final-day-balance.md",
              "summary": "# Final Daily Balance\n\nThis technical guide covers the Final Daily Balance feature of the Dune Docs project. The feature is located in the `app` folder of the project. \n\nThe Final Daily Balance feature is an Ethereum ERC20 token balances spell that expands the Spell to cover all days, not just the days with transfer activity. The feature adds price data, removes known rebase tokens, and any tokens that resulted in large negative balances. \n\nThe `balances_ethereum_erc20_day.sql` file contains the SQL code for the feature. It uses the `transfers_ethereum_erc20_rolling_day` table to derive the `balances_ethereum_erc20_noncompliant` table, which looks for unique token addresses with larger negative balances that indicate the contract may not be compliant with ERC20. The `balances_ethereum_erc20_day` table then removes rebase tokens from balances and likely non-compliant tokens due to negative balances. \n\nThe `transfers_ethereum_schema.yml` file contains the schema for the `balances_ethereum_erc20_day` table. The table provides daily token balances of ERC20 Ethereum tokens per wallet and contract address pair. The table depends on `erc20_ethereum_transfers`. \n\nOverall, the Final Daily Balance feature provides a comprehensive view of daily Ethereum ERC20 token balances, including price data and compliance checks.",
              "questions": "1. What is the purpose of the `transfers_ethereum_erc20_rolling_day` table and how is it used in the `balances_ethereum_erc20_day` SQL query?\n   \n   The blockchain SQL analyst might want to know more about the `transfers_ethereum_erc20_rolling_day` table and how it is used in the `balances_ethereum_erc20_day` SQL query to understand how the daily token balances are calculated.\n\n2. How are rebase tokens and non-compliant tokens identified and removed from the final daily balances?\n\n   The blockchain SQL analyst might want to know more about how rebase tokens and non-compliant tokens are identified and removed from the final daily balances to understand the accuracy and reliability of the data.\n\n3. What is the significance of the `prices` table and how is it used in the `balances_ethereum_erc20_day` SQL query?\n\n   The blockchain SQL analyst might want to know more about the `prices` table and how it is used in the `balances_ethereum_erc20_day` SQL query to understand how the daily token balances are converted to USD."
            },
            {
              "fileName": "index.md",
              "filePath": "docs/data-tables/spellbook/contributing/examples/index.md",
              "url": "https://dune.com/docs/data-tables/spellbook/contributing/examples/index.md",
              "summary": "The app technical guide titled \"Spellbook Examples\" provides an overview of how to track daily balances for ERC-20 tokens using the Dune app. The guide starts by introducing ERC-20 tokens and their contract standard set by the Ethereum Foundation. The main focus of the guide is to identify transfers and track daily balances using the Dune app.\n\nThe guide provides a modular series of spells that can be used to track daily balances. The first spell is \"Reformatted transfers\" which reformats the data from the `erc20_ethereum.evt_Transfer` table. The second spell is \"Daily aggregation\" which aggregates the daily transfers. The third spell is \"Rolling sum\" which calculates the rolling sum of daily transfers. The final spell is \"Final daily balances\" which calculates the final daily balances for Ethereum ERC20 tokens.\n\nThe guide also includes a video that demonstrates how to find the `erc20_ethereum.evt_Transfer` table using the data explorer. The guide is focused on the app folder of the Dune app and provides examples of how to use the app to track daily balances for ERC-20 tokens.",
              "questions": "1. What is the purpose of the Dune table `erc20_ethereum.evt_Transfer` and how does it relate to blockchain data analysis?\n   \n   A blockchain SQL analyst might want to know more about the structure and contents of the `erc20_ethereum.evt_Transfer` table, as well as how it can be used to track daily balances of ERC-20 tokens. They may also want to know how this table is populated and updated over time.\n\n2. How do the modular spells in this app technical guide work together to provide a comprehensive analysis of ERC-20 token transfers?\n\n   A blockchain SQL analyst might be interested in understanding how the different spells in this guide fit together to provide a complete picture of daily balances for ERC-20 tokens. They may also want to know how these spells can be customized or adapted for different use cases.\n\n3. Are there any limitations or potential issues with using this app technical guide for blockchain data analysis?\n\n   A blockchain SQL analyst might want to know about any potential limitations or issues with using this app technical guide, such as data quality or accuracy concerns, or any assumptions or simplifications made in the analysis. They may also want to know about any potential performance or scalability issues when working with large datasets."
            },
            {
              "fileName": "reformatted.md",
              "filePath": "docs/data-tables/spellbook/contributing/examples/reformatted.md",
              "url": "https://dune.com/docs/data-tables/spellbook/contributing/examples/reformatted.md",
              "summary": "# Reformatted Transfers\n\nThis technical guide is focused on the `app` folder of the Dune Docs project and covers the reformatted transfers feature. The purpose of this feature is to make it easier to sum up transfers by munging the base table into a union of sent transactions and received transactions. \n\nThe guide explains that WETH requires special handling due to the additional functions of deposit and withdrawal. Therefore, `zeroex_ethereum.weth9_evt_deposit` is added as a source. The model is defined in a YAML file where the description, tests, and metadata are defined. Contributors are also tracked in this file. \n\nThe JINJA config block is used to define the alias for this view as `erc20`. Without this alias, the table name would default to the file name. The schema name for this view is defined in the `dbt_project.yml` file in the root of the Spellbook project. Schema’s are defined there by the directory structure. The name of this view would be `transfers_ethereum.erc20` given the current structure.\n\nThe guide provides an SQL example of the `transfers_ethereum_erc20.sql` file, which includes four CTEs: `sent_transfers`, `received_transfers`, `deposited_weth`, and `withdrawn_weth`. These CTEs are used to select unique transaction IDs, wallet addresses, token addresses, event block times, and raw amounts for each transfer type. The `unique_tx_id`, `blockchain`, `wallet_address`, `token_address`, `evt_block_time`, and `amount_raw` columns are then selected from each CTE and unioned together to create the final table.\n\nThe `transfers_ethereum_schema.yml` file is also provided as an example. This file includes metadata such as the blockchain, sector, project, contributors, tags, and description for the `transfers_ethereum_erc20` model. The `dbt_project.yml` file is also included as an example, which defines the schema and materialized view for the `transfers` and `ethereum` folders.\n\nOverall, this technical guide provides a detailed explanation of the reformatted transfers feature in the Dune Docs app. It covers the purpose of the feature, how it works, and provides examples of the SQL, YAML, and `dbt_project.yml` files used to implement it.",
              "questions": "1. What is the purpose of the dune docs app and how does it relate to blockchain SQL analysis?\n   \n   The app is a documentation platform for spells used in Dune Analytics, which is a platform for blockchain SQL analysis. Blockchain SQL analysts may use this app to understand the data models and schemas used in Dune Analytics.\n\n2. What is the purpose of the `transfers_ethereum_erc20` model and how is it defined?\n   \n   The `transfers_ethereum_erc20` model is used to track ERC20 token transfers on the Ethereum blockchain. It is defined in a YAML file and a SQL file, where the SQL file defines the logic for the model and the YAML file defines metadata such as the description, tests, and contributors.\n\n3. How does the app handle WETH deposits and withdrawals?\n   \n   The app handles WETH deposits and withdrawals by adding `zeroex_ethereum.weth9_evt_deposit` as a source and defining two SQL queries to handle deposited and withdrawn WETH. These queries are then combined with queries for sent and received transfers to create a union of all transfer types."
            },
            {
              "fileName": "rolling-sum.md",
              "filePath": "docs/data-tables/spellbook/contributing/examples/rolling-sum.md",
              "url": "https://dune.com/docs/data-tables/spellbook/contributing/examples/rolling-sum.md",
              "summary": "# Rolling Sum of Daily Transfers\n\nThis section of the app technical guide covers the rolling sum window function applied to each daily transfer sum. The purpose of this query is to calculate the rolling sum of raw amounts of ERC20 tokens held after taking into account token decimals. The query is contained in the `transfers_ethereum_erc20_rolling_day.sql` file located in the `app` folder of the project. \n\nThe query selects the blockchain, day, wallet address, token address, symbol, last updated timestamp, recency index, and the rolling sum of the raw amount of ERC20 tokens held. The `transfers_ethereum_erc20_agg_day` reference is used to partition the data by token address and wallet address and order it by day. \n\nThe `transfers_ethereum_erc20_schema.yml` file in the `app` folder of the project contains the schema for the `transfers_ethereum_erc20_rolling_hour` table. The table includes columns for blockchain, hour, wallet address, token address, symbol, amount raw, amount, amount USD, updated at, and recency index. \n\nOverall, this section of the app technical guide provides information on how to calculate the rolling sum of raw amounts of ERC20 tokens held using a window function. It also includes the schema for the table that stores the results of this calculation.",
              "questions": "1. What is the purpose of the `rolling sum window function` in this app technical guide?\n    \n    The purpose of the `rolling sum window function` is to apply it to each daily transfer sum in order to calculate the rolling sum of raw amount of ERC20 token held.\n\n2. What is the significance of the `recency_index` column in the `transfers_ethereum_erc20_schema.yml` file?\n    \n    The `recency_index` column is an index of the most recent balance ascending, where `recency_index=1` is the wallet/contract pair's most recent balance.\n\n3. How does the `transfers_ethereum_erc20_rolling_hour` table differ from the `transfers_ethereum_erc20_agg_day` table?\n    \n    The `transfers_ethereum_erc20_rolling_hour` table calculates the rolling sum of raw amount of ERC20 token held after taking into account token decimals, while the `transfers_ethereum_erc20_agg_day` table does not."
            }
          ],
          "folders": [],
          "summary": "This folder contains a series of technical guides focused on the `app` folder of the Dune Docs project, specifically covering the process of tracking daily balances for Ethereum ERC-20 tokens. The guides provide detailed explanations of various features and functionalities, including reformatted transfers, daily aggregation, rolling sum, and final daily balances. These guides are essential for analysts who want to understand the inner workings of the Dune Docs project and how to use it effectively.\n\nThe `reformatted.md` guide explains the reformatted transfers feature, which simplifies the process of summing up transfers by creating a union of sent and received transactions. It covers the handling of WETH, the use of JINJA config blocks, and provides examples of the `transfers_ethereum_erc20.sql` and `transfers_ethereum_schema.yml` files.\n\nThe `daily-aggregation.md` guide covers the daily aggregation feature, which sums all transfers for the day. It explains the incremental nature of the feature, the use of merge strategies, and the concept of refs. The guide also provides examples of the `transfers_ethereum_erc20_agg_day.sql` file and the `transfers_ethereum_schema.yml` file.\n\nThe `rolling-sum.md` guide focuses on the rolling sum window function applied to each daily transfer sum. It explains how to calculate the rolling sum of raw amounts of ERC20 tokens held, using the `transfers_ethereum_erc20_rolling_day.sql` file. The guide also includes the schema for the `transfers_ethereum_erc20_rolling_hour` table, as found in the `transfers_ethereum_erc20_schema.yml` file.\n\nThe `final-day-balance.md` guide covers the Final Daily Balance feature, which provides a comprehensive view of daily Ethereum ERC20 token balances, including price data and compliance checks. It explains the use of the `balances_ethereum_erc20_day.sql` file and the schema for the `balances_ethereum_erc20_day` table, as found in the `transfers_ethereum_schema.yml` file.\n\nLastly, the `index.md` guide provides an overview of the entire process of tracking daily balances for ERC-20 tokens using the Dune app. It introduces the concept of ERC-20 tokens and their contract standard, as well as the modular series of spells used to track daily balances.\n\nThese guides are useful for analysts who want to gain a deeper understanding of the Dune Docs project and its features. By following the examples provided in the guides, analysts can effectively track daily balances for ERC-20 tokens and make informed decisions based on the data.",
          "questions": ""
        }
      ],
      "summary": "The `contributing` folder in the Dune Docs project focuses on the process of contributing a new Spell to the Spellbook, which is an open-source dbt repository for creating and maintaining high-level blockchain data tables using SQL and Jinja templating. The guides in this folder provide detailed instructions on how to set up Spellbook dbt, decide on a Spell to cast, set up a file structure for SQL, schema, and source files, identify and define sources, define expectations with schema and tests, write a Spell as a SELECT statement, configure alias and materialization strategy, and make a pull request to become an Archwizard.\n\nFor example, the guide \"2-decide-on-a-Spell-to-cast.md\" helps users decide on a Spell to cast by providing three ways to decide on a Spell, including having an idea based on previous experience with Dune, checking out Spellbook bounties in Dework, or asking for suggestions in the #spellbook Discord channel. The guide also provides an example of creating a migration Spell, specifically translating the Keep3r network `view_job_log` abstraction from Dune's v1 database into a V2 Spell.\n\nAnother example is the guide \"6-write-your-spell-as-SELECT-statement.md\", which covers the process of writing a Spell as a SELECT statement in the Dune Docs project. The guide provides a step-by-step process of migrating from V1 abstraction to V2 Spell, replacing hard-coded references with JINJA templating, and testing the SQL code and fixing errors.\n\nThese guides are useful for analysts and developers who want to contribute to the Spellbook project by creating and maintaining high-level blockchain data tables. By following the instructions provided in these guides, users can ensure that their Spells are properly structured, tested, and integrated into the Spellbook project. This will ultimately help make blockchain data more transparent, accessible, and meaningful for the entire community.\n\nOverall, the guides in this folder provide a comprehensive explanation of how to contribute a new Spell to the Spellbook project, making it easier for users to create and maintain high-level blockchain data tables using SQL and Jinja templating. The guides are well-structured and include examples to help users understand the process and contribute effectively to the project.",
      "questions": ""
    },
    {
      "folderName": "top tables",
      "folderPath": "docs/data-tables/spellbook/top tables",
      "url": "https://dune.com/docs/data-tables/spellbook/top tables",
      "files": [
        {
          "fileName": "dex.trades.md",
          "filePath": "docs/data-tables/spellbook/top tables/dex.trades.md",
          "url": "https://dune.com/docs/data-tables/spellbook/top tables/dex.trades.md",
          "summary": "# Dex.Trades App Technical Guide\n\nThe Dex.Trades app is a decentralized exchange aggregator that collects data from multiple DEX platforms into one simple table. This guide provides an overview of the app and its features.\n\n## Overview\n\nDecentralized exchanges are the backbone of the DeFi industry, allowing users to swap any native (ETH) or ERC-20 token for any ERC-20 token through smart contracts. However, with so many decentralized exchanges available, it can be challenging to work with the smart contract data for all of them. Dex.Trades solves this problem by standardizing and normalizing trading data across virtually all relevant decentralized exchanges.\n\n## Column Data\n\nThe Dex.Trades table contains the following columns:\n\n- `block_time`: The timestamp of the block that included this transaction.\n- `token_a_symbol`: The symbol of one of the two tokens that got traded.\n- `token_b_symbol`: The symbol of one of the two tokens that got traded.\n- `token_a_amount`: The amount of token A that got traded.\n- `token_b_amount`: The amount of token B that got traded.\n- `project`: The DEX on which this trade was executed.\n- `version`: Which version of the DEX got used?\n- `blockchain`: Which blockchain did this occur on?\n- `taker`: Which contract called the DEX contract?\n- `maker`: In some special cases, there actually is a counterparty to transactions, and this party will get displayed here if applicable.\n- `token_a_amount_raw`: The raw amount of token A that got traded.\n- `token_b_amount_raw`: The raw amount of token B that got traded.\n- `usd_amount`: The USD value of this trade.\n- `token_a_address`: The ERC-20 token contract address of token A.\n- `token_b_address`: The ERC-20 token contract address of token B.\n- `exchange_contract_address`: The address of the decentralized exchange contract that made this trade possible.\n- `tx_hash`: The hash of the transaction that contained this trade.\n- `tx_from`: Which address initiated this transaction?\n- `tx_to`: What was the first smart contract that got called during this tx?\n- `trace_address`: Which position in the graph tree does the execution of the trade have?\n- `evt_index`: This logs index position in the block (cumulative amount of logs ordered by execution).\n- `trade_id`: Just for database magic.\n\n## Conclusion\n\nThe Dex.Trades app is an essential tool for anyone looking to work with decentralized exchanges. By aggregating data across multiple DEX platforms into one simple table, Dex.Trades makes it easy to query for trading data for your favorite tokens without having to deal with all of the different DEX smart contracts yourself. The scripts that generate the table can be found in the public Github repo.",
          "questions": "1. What is the purpose of dex.trades and how does it work?\n- Answer: dex.trades is a table that standardizes and normalizes trading data across multiple decentralized exchanges, making it easier to query for trading data for different tokens without having to deal with different DEX smart contracts. It works by aggregating data from various DEX platforms into one simple table.\n\n2. What specific data is included in the dex.trades table?\n- Answer: The dex.trades table includes data such as the timestamp of the block that included the transaction, the symbols and amounts of the tokens traded, the DEX on which the trade was executed, the blockchain on which it occurred, the contract addresses involved, and the USD value of the trade.\n\n3. Where can the scripts that generate the dex.trades table be found?\n- Answer: The scripts that generate the dex.trades table can be found in the public github repo at https://github.com/duneanalytics/spellbook/tree/master/ethereum/dex."
        },
        {
          "fileName": "labels.md",
          "filePath": "docs/data-tables/spellbook/top tables/labels.md",
          "url": "https://dune.com/docs/data-tables/spellbook/top tables/labels.md",
          "summary": "# Labels\n\nThe Labels technical guide is a feature on Dune that allows users to add, update, and query labels for any address. The guide explains what labels are, how to add them, and how to use them. \n\nA label is a piece of metadata about an address, a tag, or metadata. It comes in the form of a key-value pair. The key is the label type, and the value is the label name. Users can browse addresses and labels on the labels page. Labels on Dune are open-ended and crowd-sourced, meaning users are free to come up with new types and label names. \n\nThe guide provides examples of what users can do with labels, such as labeling all addresses that used a certain dapp, labeling all addresses that hold a certain amount of a token, labeling all addresses that use a dapp more than X times per month, and labeling all addresses that sent money to Binance. Users can also do more novel and involved things around user patterns like who did arbitrage trades or profited from flash loans and so much more.\n\nThe Labels table stores labels in the new `labels.labels` table, which has the following schema: `id`, `address`, `name`, `blockchain`, `author`, `source`, `updated_at`, `label_type`, and `model_name`. \n\nThe guide also provides a warning that the Using Labels section is currently under construction. \n\nOverall, the Labels technical guide provides a comprehensive overview of the Labels feature on Dune, including what labels are, how to add them, and how to use them. It also provides examples of what users can do with labels and explains how labels are stored in the Labels table.",
          "questions": "1. What is the purpose of the Labels feature on Dune?\n- The Labels feature on Dune allows users to add, update, and query labels for any address, providing metadata about an address in the form of a key-value pair.\n\n2. How are labels created on Dune?\n- Labels on Dune are open-ended and crowd-sourced, meaning users are free to come up with both new types and label names. Labels can be added using Dune queries, which can be used to label addresses based on various criteria such as dapp usage, token holdings, and more.\n\n3. What is the schema of the `labels.labels` table?\n- The `labels.labels` table stores labels and has columns for the label ID, address, name, blockchain, author, source, updated_at, label_type, and model_name."
        },
        {
          "fileName": "nft.trades.md",
          "filePath": "docs/data-tables/spellbook/top tables/nft.trades.md",
          "url": "https://dune.com/docs/data-tables/spellbook/top tables/nft.trades.md",
          "summary": "The `nft.trades` technical guide is a documentation of the effort to make NFT trading data easily available to everyone on Dune. The guide provides an overview of the `nft.trades` table, which aggregates and standardizes the data between different data platforms and provides auxiliary information and metadata all in one table. The guide explains how the dataset makes it extremely easy to query for any NFT related trading data across all indexed platforms. \n\nThe guide provides information on how the `nft.trades` table works, including Single Item Trade, Bundle Trade, and Aggregator Trade. The Single Item Trade occurs between a buyer and a seller, and they exchange an item that is uniquely identified by the combination of `nft_contract_address` and `token_id`. The Bundle Trade contains multiple items, and each of these items is uniquely identified through a combination of `nft_contract_address` and `token_id`. The Aggregator Trade is a trade in which a single trade transaction contains multiple items, and the approach is to unravel aggregator trades so that each row corresponds to a unique item that was traded, with its associated ID, price, collection, etc.\n\nThe guide also provides information on Platform and Royalty Fees. In the most recent version of `nft.trades`, information about the amount and percent of royalty fees in the original amount and in USD is available when this information was able to be retrieved. Royalty fees are going to the creator, and Platform fees are collected by the NFT platform. \n\nThe guide provides examples of queries that can be run on the `nft.trades` table, including All trades for a given NFT, Trades in the last 24 hour on a given platform, and Platform volumes in the last year. The guide also provides examples of dashboards that utilize parameters and look across the entire ecosystem.\n\nFinally, the guide provides a column data table that lists the column name, data type, and description of the `nft.trades` table. The guide also explains that the SQL code that processes the data for every marketplace is open source and available in their GitHub repository. Everyone can review the code, make pull requests, and submit code to add more marketplaces.",
          "questions": "1. What platforms are currently indexed by nft.trades?\n- OpenSea, Rarible, SuperRare, CryptoPunks, Foundation, and LooksRare are currently indexed by nft.trades.\n\n2. What metadata is provided about the traded NFT?\n- The metadata provided about the traded NFT includes nft_project_name and erc_standard.\n\n3. Can a blockchain SQL analyst add their own aggregator platform to the nft.trades table?\n- Yes, a blockchain SQL analyst can make a pull request to add their own aggregator platform to the nft.trades table."
        },
        {
          "fileName": "prices.md",
          "filePath": "docs/data-tables/spellbook/top tables/prices.md",
          "url": "https://dune.com/docs/data-tables/spellbook/top tables/prices.md",
          "summary": "# Prices\n\nThis technical guide covers the `Prices` feature of the Dune Docs project. The `Prices` feature allows users to get the price of almost all relevant ERC20 tokens. The data is pulled from the Coinpaprika API and the price is the volume-weighted price based on real-time market data, translated to USD.\n\nThe guide provides two tables for getting prices: `prices.usd` and `prices_from_dex_data`. The `prices.usd` table supports a range of ERC20 tokens. If the token you desire is not listed in this table, you can make a pull request to the GitHub repository. The `prices_from_dex_data` table creates price feeds based on decentralized exchange trading data. This table covers much more assets than `prices.usd`, since it covers all assets that are traded on any of the decentralized exchanges that are indexed in `dex.trades`. However, this table is very resource-intensive and can only be updated every few hours. Also, the resolution is only hourly, so if you need minutely prices, you should refer to `prices.usd`.\n\nThe guide provides a detailed explanation of how the `prices_from_dex_data` table works. The script generates median hourly prices based on data from decentralized exchanges found in `dex.trades`. It assigns asset prices based on a trading pair which has a price feed in `prices.usd`. For example, if the $SPELL/ETH pool is used, the $ETH price is contained in `prices.usd`, but the $SPELL price is not. In order to get the $SPELL price, the script will dynamically calculate the price of $SPELL based on the price of $ETH that was exchanged for it. The guide provides an example of how this calculation is done.\n\nThe guide also highlights known issues with the `prices_from_dex_data` table. In rare cases, the script will generate price feeds that are based on illiquid pairs and therefore report wrong data. This happens when all liquid trading pools of this token do not have a price feed in `prices.usd`. The guide provides an example of how this issue can occur and how to manually construct a price feed in such cases.\n\nOverall, this technical guide provides a comprehensive explanation of the `Prices` feature of the Dune Docs project, including how to use the `prices.usd` and `prices_from_dex_data` tables, how the `prices_from_dex_data` table works, and known issues with the table.",
          "questions": "1. What is the source of the price data for the decentralized exchange trading data table?\n- The source of the price data for the decentralized exchange trading data table is the trading data from decentralized exchanges found in `dex.trades`.\n\n2. What is the resolution for the `prices.usd` table?\n- The resolution for the `prices.usd` table is by minute.\n\n3. What are the known issues with the script that generates median hourly prices based on data from decentralized exchanges found in `dex.trades`?\n- In rare cases, the script will generate price feeds that are based on illiquid pairs and therefore report wrong data. This happens when all liquid trading pools of a token do not have a price feed in `prices.usd`. In cases like this, a manual price feed construction is required."
        },
        {
          "fileName": "tokens.md",
          "filePath": "docs/data-tables/spellbook/top tables/tokens.md",
          "url": "https://dune.com/docs/data-tables/spellbook/top tables/tokens.md",
          "summary": "# Tokens\n\nThis section of the app technical guide for the Dune Docs project covers token transfers and metadata. The guide is aimed at individuals who will be working with fungible (ERC20) and non-fungible (ERC721 and ERC1155) tokens in their analysis. The guide provides information on two metadata tables and two transfer tables that are essential for working with tokens.\n\nThe metadata tables include:\n\n1. `tokens.erc20`: This table contains useful information such as the token `symbol` and the `decimals` for any given `contract_address`. The `decimals` information is needed to get the actual amount from raw amounts in on-chain data.\n\n2. `tokens.nft`: This table contains the collection `name` and `symbol` for any given `contract_address`.\n\nThese tables are usually joined on `contract_address` at the end of a query to make everything more human-readable.\n\nThe transfer tables include:\n\n1. `erc20_ethereum.evt_Transfer`: This table contains all transfer events for every ERC20 token. The guide provides a link to a video guide that explains how to get ERC20 balances, mints, and burns.\n\n2. `nft.transfers`: This table contains all transfer events for every ERC721 or ERC1155 token. The guide provides a link to a guide that explains how to leverage this table to find NFT balances, transfers, and mints.\n\nIf you're looking for information on how to calculate native token balances like Ethereum (ETH) balances, the guide provides a link to another guide that covers this topic.\n\nOverall, this section of the app technical guide provides essential information for individuals working with tokens in their analysis. The metadata and transfer tables are crucial for understanding token transfers and metadata, and the guide provides links to additional resources for further learning.",
          "questions": "1. What types of tokens does this app support?\n- The app supports both fungible (erc20) and nonfungible (erc721 and erc1155) tokens.\n\n2. What information can be found in the metadata tables?\n- The metadata tables contain information such as the token symbol, decimals, collection name, and symbol for a given contract address.\n\n3. What transfer events can be found in the transfer tables?\n- The transfer tables contain all transfer events for erc20, erc721, and erc1155 tokens, and can be used to find balances, transfers, mints, and burns."
        }
      ],
      "folders": [],
      "summary": "This folder contains technical guides for various features and tables related to the Dune Docs project, specifically focusing on data tables and their usage. These guides provide detailed explanations, examples, and use cases for working with different aspects of the project, such as decentralized exchange trades, labels, NFT trades, token prices, and token metadata.\n\nFor example, the `dex.trades.md` guide covers the Dex.Trades app, which is a decentralized exchange aggregator that collects data from multiple DEX platforms into one simple table. This guide provides an overview of the app, its features, and the columns in the Dex.Trades table. This guide is useful for anyone looking to work with decentralized exchanges and aggregate data across multiple DEX platforms.\n\nThe `labels.md` guide focuses on the Labels feature, which allows users to add, update, and query labels for any address. This guide explains what labels are, how to add them, and how to use them. It also provides examples of what users can do with labels and explains how labels are stored in the Labels table.\n\nThe `nft.trades.md` guide documents the effort to make NFT trading data easily available on Dune. It provides an overview of the `nft.trades` table, which aggregates and standardizes the data between different data platforms and provides auxiliary information and metadata all in one table. This guide is useful for anyone looking to query NFT related trading data across all indexed platforms.\n\nThe `prices.md` guide covers the Prices feature,",
      "questions": ""
    }
  ],
  "summary": "The `spellbook` folder in the Dune Docs project focuses on the concept of Spells, which are custom tables constructed and maintained by Dune and the community. These tables are designed to make it easier for users to query and analyze blockchain data. The folder contains a main guide, `index.md`, which provides a comprehensive overview of Spells, the Spellbook, and how to contribute to the project. Additionally, there are two subfolders, `contributing` and `top tables`, which contain more specific guides on contributing new Spells and working with various data tables.\n\nThe `index.md` guide introduces Spells and the Spellbook, explaining their benefits and how they can be used with Dune V2 and Spark SQL. It also covers Sector Spells and Project Spells, which standardize data across multiple contracts and projects, making it easier to compare metrics and assemble data into one neat table. This guide is useful for anyone looking to understand how to use Spells and contribute to the Spellbook project.\n\nThe `contributing` subfolder contains guides that focus on the process of contributing a new Spell to the Spellbook. These guides provide detailed instructions on setting up Spellbook dbt, deciding on a Spell to cast, setting up a file structure, defining sources and expectations, writing a Spell as a SELECT statement, and making a pull request. For example, the guide \"6-write-your-spell-as-SELECT-statement.md\" covers the process of writing a Spell as a SELECT statement, migrating from V1 abstraction to V2 Spell, and testing the SQL code. These guides are useful for analysts and developers who want to contribute to the Spellbook project by creating and maintaining high-level blockchain data tables.\n\nThe `top tables` subfolder contains technical guides for various features and tables related to the Dune Docs project. These guides provide detailed explanations and examples for working with different aspects of the project, such as decentralized exchange trades, labels, NFT trades, token prices, and token metadata. For instance, the `dex.trades.md` guide covers the Dex.Trades app, which is a decentralized exchange aggregator that collects data from multiple DEX platforms into one simple table. This guide is useful for anyone looking to work with decentralized exchanges and aggregate data across multiple DEX platforms.\n\nOverall, the `spellbook` folder in the Dune Docs project provides a comprehensive explanation of Spells, the Spellbook, and how to contribute to the project. It is a valuable resource for analysts and developers who want to create and maintain high-level blockchain data tables using SQL and Jinja templating, making blockchain data more transparent, accessible, and meaningful for the entire community.",
  "questions": ""
}